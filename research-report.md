# 动漫观看进度微信小程序 - 技术调研报告

> 调研日期：2025年11月
>
> 项目定位：个人动漫观看记录和进度管理小程序

---

## 一、项目需求概述

### 1.1 核心功能需求

本项目旨在开发一款动漫观看进度管理微信小程序，第一版本迭代需实现以下核心功能：

1. **动漫搜索**：支持中文/日文搜索动漫作品
2. **进度记录**：记录用户观看进度（季/集级别），按用户隔离
3. **用户系统**：微信登录 + 手机号快速注册、头像设置、6位UID生成
4. **界面设计**：参考豆瓣手机App风格
5. **收藏系统**：支持"想看"、"在看"、"看过"三种状态标记
6. **喜欢功能**：独立的点赞/喜欢功能
7. **内容范围**：主要覆盖日本动漫和中国动漫

### 1.2 技术选型目标

- 前后端合一的Node.js框架，降低开发复杂度
- 免费且更新及时的动漫数据源
- 快速开发、易维护
- 良好的用户体验

---

## 二、前后端框架调研

### 2.1 微信小程序开发框架对比

#### 2.1.1 主流框架对比

| 框架 | 语法 | 多端支持 | 生态 | 学习成本 | 推荐度 |
|------|------|----------|------|----------|--------|
| **Taro** | React/Vue | 10+ 平台 | ⭐⭐⭐⭐⭐ | 中 | ⭐⭐⭐⭐⭐ |
| Uni-app | Vue | 10+ 平台 | ⭐⭐⭐⭐⭐ | 低 | ⭐⭐⭐⭐ |
| 原生MINA | WXML/WXSS | 仅微信 | ⭐⭐⭐ | 低 | ⭐⭐⭐ |
| Kbone | Web标准 | 多端 | ⭐⭐⭐ | 中 | ⭐⭐⭐ |

#### 2.1.2 Taro 框架详解

**技术特点：**
- 京东凹凸实验室开源，社区活跃
- 使用 React 或 Vue 语法开发
- 编译到多端：微信、支付宝、百度、字节跳动、QQ小程序、H5、React Native等
- 支持TypeScript
- 完善的开发工具链

**优势：**
- 开发体验接近现代Web开发
- 丰富的组件库（Taro UI）
- 可复用React生态
- 良好的文档和社区支持
- 跨平台能力强（虽然本项目暂不需要）

**当前版本：** Taro 3.x（2025年最新稳定版）

**官方文档：** https://docs.taro.zone

### 2.2 后端架构方案

#### 2.2.1 微信云开发（Serverless）✅ 推荐

**架构组成：**
```
微信云开发 = 云函数 + 云数据库 + 云存储 + CDN
```

**技术栈：**
- **云函数**：Node.js 运行时，支持 ES6+
- **云数据库**：基于MongoDB的文档型数据库
- **云存储**：图片、文件存储（用户头像）
- **云调用**：直接调用微信开放接口

**核心优势：**

1. **零运维成本**
   - 无需购买服务器
   - 无需配置域名、SSL证书
   - 自动扩容，按量计费

2. **开发效率高**
   - 前后端使用统一的JavaScript/Node.js
   - 内置微信登录能力
   - SDK简单易用（wx-server-sdk）

3. **安全性好**
   - 天然的用户身份鉴权
   - 数据库权限精细控制
   - HTTPS加密传输

4. **免费额度**
   - 云函数：每月40万次调用
   - 云数据库：2GB存储
   - 云存储：5GB存储
   - 流量：5GB/月
   - **足够支撑初期几千用户使用**

**示例代码：**
```javascript
// 云函数示例：获取用户观看记录
const cloud = require('wx-server-sdk')
cloud.init()
const db = cloud.database()

exports.main = async (event, context) => {
  const { animeId } = event
  const wxContext = cloud.getWXContext()

  // 自动获取用户openid，无需传递
  const userOpenId = wxContext.OPENID

  // 查询数据库
  return await db.collection('watch_records')
    .where({
      userId: userOpenId,
      animeId: animeId
    })
    .get()
}
```

#### 2.2.2 其他方案对比

**传统自建后端（Express/Koa + MySQL/MongoDB）**

优势：
- 完全可控，灵活性高
- 适合复杂业务逻辑

劣势：
- 需要购买服务器（成本）
- 需要运维（精力投入）
- 需要备案域名
- 开发周期长

**结论：** 对于本项目的第一版迭代，**微信云开发**是最佳选择，可大幅缩短开发周期。

---

## 三、动漫数据源调研

### 3.1 Bangumi API ✅ 推荐

**项目信息：**
- 官网：https://bangumi.github.io/api/
- 类型：开源社区驱动的动漫数据库
- 定位：中文动漫爱好者社区

**核心优势：**

1. **中文友好**
   - 提供中文名称（name_cn）和日文名称（name）
   - 支持中文搜索
   - 适合国内用户使用

2. **数据全面**
   - 涵盖日本动漫、中国动漫
   - 包含分季、分集信息
   - 提供评分、简介、图片等元数据

3. **完全免费**
   - 无API Key要求
   - 无请求频率限制（合理使用）
   - 无需付费订阅

4. **更新及时**
   - 社区驱动，新番更新快
   - 用户贡献数据

**API示例：**

```http
# 搜索动漫
GET https://api.bgm.tv/search/subject/进击的巨人?type=2

# 获取动漫详情
GET https://api.bgm.tv/subject/55770

# 获取分集信息
GET https://api.bgm.tv/subject/55770/ep
```

**返回数据结构：**
```json
{
  "id": 55770,
  "name": "進撃の巨人",
  "name_cn": "进击的巨人",
  "summary": "作品简介...",
  "eps": 25,
  "air_date": "2013-04-07",
  "images": {
    "large": "https://...",
    "common": "https://...",
    "medium": "https://...",
    "small": "https://...",
    "grid": "https://..."
  },
  "rating": {
    "total": 12345,
    "score": 8.5
  }
}
```

**使用建议：**
- 前端搜索时调用Bangumi API
- 将常用数据缓存到云数据库，减少API调用
- 用户收藏的动漫，定期同步最新信息

### 3.2 其他数据源对比

#### 3.2.1 Jikan API (MyAnimeList)

**优势：**
- 全球最大动漫数据库
- 数据最全面

**劣势：**
- 限流严格（30请求/分钟，2请求/秒）
- 中文数据较少，主要是日文+英文
- 对中国动漫支持不足

**结论：** 不适合本项目

#### 3.2.2 AniList API

**优势：**
- GraphQL接口，灵活强大
- 数据丰富

**劣势：**
- 需要OAuth认证
- 中文支持一般
- 学习成本高

**结论：** 可作为Bangumi的补充数据源，但不作为主数据源

### 3.3 数据源方案总结

**推荐方案：以Bangumi API为主**

架构设计：
```
用户搜索 → Bangumi API搜索
       ↓
    云数据库缓存（24小时）
       ↓
  返回给前端展示
```

优点：
- 减少API调用
- 提升响应速度
- 数据本地化，支持离线查看

---

## 四、UI组件库调研

### 4.1 Taro UI ✅ 推荐

**项目信息：**
- 开发者：京东凹凸实验室（O2Team）
- 官网：https://taro-ui.jd.com/
- GitHub：https://github.com/jd-opensource/taro-ui

**组件丰富度：**
- 基础组件：Button、Icon、Badge等
- 表单组件：Input、Textarea、Checkbox、Radio等
- 布局组件：Grid、Card、List等
- 导航组件：TabBar、NavBar、Tabs等
- 反馈组件：Toast、Modal、Loading等
- **共计40+组件**

**技术特点：**
- 基于Taro开发，完美集成
- 支持多端（本项目只用微信端）
- 支持主题定制
- TypeScript支持

**界面风格：**
- 简洁现代
- 符合小程序设计规范
- 可自定义样式（便于模仿豆瓣风格）

**示例代码：**
```jsx
import { AtCard, AtButton, AtTag } from 'taro-ui'

<AtCard
  title='进击的巨人'
  extra='2013'
  thumb='https://...'
>
  <AtTag type='primary'>日本</AtTag>
  <AtTag>动作</AtTag>
  <View>评分：8.5</View>
  <AtButton type='primary'>标记想看</AtButton>
</AtCard>
```

### 4.2 其他UI框架对比

**WeUI**
- 微信官方设计
- 原生风格
- 组件较少

**自定义设计**
- 完全符合豆瓣风格
- 开发周期长
- 维护成本高

**结论：** 使用Taro UI作为基础，在此之上自定义样式模仿豆瓣风格，平衡开发效率和设计需求。

---

## 五、用户系统方案

### 5.1 微信登录流程

**技术方案：**
```
小程序调用 wx.login()
      ↓
   获取 code
      ↓
云函数接收 code
      ↓
调用微信接口换取 openid
      ↓
存储/查询用户信息
      ↓
返回自定义登录态
```

**优势：**
- 用户无感知，一键登录
- 安全可靠
- 云开发内置支持

### 5.2 手机号注册

**实现方案：**

1. **微信授权手机号（推荐）**
   ```jsx
   <button open-type="getPhoneNumber" onGetPhoneNumber={handleGetPhone}>
     绑定手机号
   </button>
   ```
   - 用户授权后，云函数自动获取手机号
   - 无需短信验证码
   - 但需要企业认证（个人小程序不支持）

2. **短信验证码注册（备选）**
   - 使用腾讯云短信服务
   - 用户输入手机号 + 验证码
   - 适合个人小程序

### 5.3 UID生成方案

**需求：** 为每个用户生成一个6位数字UID，类似豆瓣的用户ID

**方案一：递增ID**
```javascript
// 云函数
const db = cloud.database()
const _ = db.command

// 使用计数器表
await db.collection('counters').doc('user_uid').update({
  data: {
    seq: _.inc(1)  // 自增
  }
})
```

**方案二：随机6位数 + 去重**
```javascript
function generateUID() {
  return Math.floor(100000 + Math.random() * 900000).toString()
}

// 循环检查是否重复
let uid = generateUID()
while (await isUIDExist(uid)) {
  uid = generateUID()
}
```

**推荐：** 方案一（递增ID），简单可靠，用户友好。

### 5.4 用户头像设置

**方案：**
1. 默认使用微信头像（wx.getUserProfile）
2. 支持用户自定义上传头像
3. 存储到云存储（cloud.uploadFile）
4. 数据库保存云存储路径

```javascript
// 上传头像
wx.chooseImage({
  count: 1,
  success: res => {
    wx.cloud.uploadFile({
      cloudPath: `avatars/${userId}_${Date.now()}.png`,
      filePath: res.tempFilePaths[0],
      success: uploadRes => {
        // 更新数据库用户头像字段
        updateUserAvatar(uploadRes.fileID)
      }
    })
  }
})
```

---

## 六、豆瓣风格界面设计参考

### 6.1 豆瓣App设计特点

**色彩方案：**
- 主色：豆瓣绿 #00B51D / #42BD56
- 辅助色：橙色（评分）、灰色（次要信息）
- 背景：浅灰白色 #F5F5F5

**布局特点：**
- 卡片式设计
- 大量使用横向封面图
- 清晰的信息层级
- 圆角矩形元素

**典型页面结构：**
```
┌─────────────────────┐
│  导航栏              │
├─────────────────────┤
│  搜索框              │
├─────────────────────┤
│ ┌─────┐ 动漫名称    │
│ │封面 │ 评分 ★8.5   │
│ │图片 │ [想看] 按钮  │
│ └─────┘             │
├─────────────────────┤
│ ┌─────┐ 动漫名称    │
│ │封面 │ 评分 ★7.8   │
│ │图片 │ [在看] 按钮  │
│ └─────┘             │
└─────────────────────┘
```

### 6.2 实现建议

**使用Taro UI组件：**
- `AtCard`：动漫卡片
- `AtRate`：评分星级
- `AtTag`：标签（类型、年份）
- `AtButton`：操作按钮
- `AtTabs`：想看/在看/看过切换

**自定义样式：**
```scss
// 豆瓣绿主题
$primary-color: #42BD56;

.anime-card {
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);

  .cover {
    width: 100px;
    height: 140px;
    border-radius: 4px;
  }

  .rating {
    color: #F99600;  // 豆瓣橙
    font-size: 18px;
  }
}
```

---

## 七、技术栈总结

### 7.1 最终技术选型

| 层级 | 技术 | 说明 |
|------|------|------|
| **前端框架** | Taro 3.x + React | 使用React语法开发小程序 |
| **UI组件库** | Taro UI | 基础组件+自定义豆瓣风格 |
| **后端架构** | 微信云开发 | Serverless，零运维 |
| **云函数** | Node.js | 业务逻辑处理 |
| **数据库** | 云数据库（MongoDB） | 用户数据、观看记录 |
| **云存储** | 微信云存储 | 用户头像 |
| **数据源** | Bangumi API | 动漫元数据 |
| **开发语言** | TypeScript | 类型安全 |
| **状态管理** | React Hooks | 简单高效 |
| **样式** | SCSS | CSS预处理 |

### 7.2 技术栈优势

**开发效率：**
- 前后端统一使用JavaScript/TypeScript
- 云开发零配置，开箱即用
- Taro UI提供丰富组件，减少重复开发

**成本优势：**
- 云开发免费额度充足
- 无需购买服务器
- Bangumi API完全免费

**可维护性：**
- 代码结构清晰
- TypeScript类型检查
- 社区活跃，问题易解决

**用户体验：**
- 微信登录无感知
- 响应速度快（云数据库缓存）
- 界面美观（参考豆瓣设计）

### 7.3 潜在风险与应对

**风险一：Bangumi API不稳定**
- 应对：本地缓存常用数据，降低依赖
- 备选：集成AniList作为备用数据源

**风险二：云开发免费额度超限**
- 应对：合理设计缓存策略，减少函数调用
- 监控：开启用量监控，及时预警

**风险三：用户量增长后性能问题**
- 应对：数据库索引优化
- 扩展：云开发支持弹性扩容

---

## 八、调研结论

### 8.1 技术方案可行性评估

**综合评分：⭐⭐⭐⭐⭐（5/5）**

本技术方案具备以下优势：
1. **快速上线**：预计2-3周完成第一版开发
2. **低成本**：免费额度足够初期使用
3. **易维护**：技术栈简单统一
4. **可扩展**：后续可平滑升级

### 8.2 建议与下一步

**建议：**
1. 优先完成核心功能（搜索、记录、标记）
2. 界面设计分阶段优化，先功能后美化
3. 上线后收集用户反馈，快速迭代

**下一步：**
- 详细的项目实施方案（见 implementation-plan.md）
- 数据库表结构设计
- API接口设计
- 开发计划排期

---

**调研完成日期：** 2025年11月17日

**文档版本：** v1.0
